name,controlId,subControlId,description,cloudProviders,policy,rule,id
The Container Image Must Be Built with the SSH Server Daemon Disabled,1,CCI-000381,"A container image must only enable the applications needed for the service being implemented by the container image. The Secure Shell (SSH) daemon is run on a server to allow the system administrator (SA) to look at logs, change configurations, install patches, or backup data. A new container must be created when new packages are needed for the service, security patches are installed, or configurations change. Data backups and restoration are done by storing data to persistent volumes that can be backed up and restored when needed. If logs need to be viewed, the SA can attach them to the container or logs sent to external logging tools.",,restrict-ssh-ports,,
The Container Image Must Be Created to Execute as a Non-Privileged User,2,CCI-002235,"Containers must run as a non-privileged account. Allowing a container to run as a privileged user leads to containers that can access host system-protected resources and execute privileged commands. If the container also mounts host system directories, it can act as a privileged user on the host system.
To implement the practice of a container running as a non-privileged user, the container image must be built with a non-privileged user in the build file, often referred to as the USER statement. When a container image is not built in this way, user namespace mapping can be used to map the container runtime user to a non-privileged account.",,require-run-as-nonroot,,
The Container Image Must Have Permissions Removed from Executables that Allow a User to Execute Software at Higher Privileges,3,CCI-002235,"Privileged execution is a serious issue to address when securing a container. Privilege escalation occurs when a user or application gains access to the privileges of another user. The user or application can use the elevated privileges to steal confidential data or cause harm to the hosting system. For Linux container images, removing setuid and setgid permissions on executables within the container image when it is created prevents privilege escalation attacks within the container when it is deployed.",,disallow-privilege-escalation,,
The Container Image Must Be Built Using Commands that Result in Known Outcomes,4,CCI-000381,"Besides loading packages from trusted sources, it is important to use consistently performing commands with known outcomes when building the container image. For example, the COPY command is a safe build command that puts files inside a container image during creation. This command copies the files from the local host machine to the container file system. The ADD instruction command can be used to put files into a container image and could potentially retrieve files from remote Uniform Resource Locators (URLs) to perform operations such as unpacking. By performing operations or tasks outside the simple task of copying a file, the ADD instruction introduces risks such as adding malicious files from URLs without scanning and unpacking possible vulnerabilities. It is always good practice to ensure containers can be built without connection to the internet. This ensures packages are loaded and built from trusted sources.",,restrict-image-build-commands,,
The Container Image Must Only Expose Non-Privileged Ports,5,CCI-001762,"Privileged ports, those below 1024, can only be used by privileged users such as root on Linux. For a container to have access to these ports, it must be running as a privileged user, however this creates a security risk since the container could perform any privileged actions on the host system, especially if a malicious user were to gain access to the container. To handle services implemented within a container that typically execute on privileged ports, such as a web server listening on port 80, use the container platform to map the privileged port to the unprivileged port within the container, e.g., map port 80 to port 8080 within the container.",,restrict-privileged-ports,,
The Container Image Must Be Built with a Process Health Check,6,CCI-002385,"Ensuring a container service is still executing and handling workloads is necessary to validate service availability. Adding the health check instruction, HEALTHCHECK, within Docker, to the container image, provides a mechanism for the container platform to periodically check the running container instance against that instruction to ensure the instance is still working. Based on the reported health status, the container platform can then exit a non-working container and instantiate a new one bringing the service back to an available state. Short lived containers that do not require a health check can be submitted for a waiver.",,require-pod-probes,,
Container Image Creation Must Use TLS 1.2 or Higher for Secure Container Image Registry Pulls,7,CCI-002418,"Image authenticity can be ensured by pulling images from trusted and approved sources, protecting the image during transmission, and validating the image once received. To protect the image during transmission, it is necessary to use a transport protocol that encrypts traffic and cannot be intercepted and modified.
Currently, sensitive data including container images, is protected by using Transport Layer Security (TLS) version 1.2 or newer. Further guidance can be found in NIST Special Publication 800-52 Rev23.",,restrict-image-registries,,
The Container Image Should Be Built with Minimal Cached Layers,8,CCI-002617,"Reducing the number of container image layers is a best practice when creating container images, but often leads to container image creation files that contain a single line made up of multiple instructions. The container image contains fewer layers, but the layers can become cached during the build process. The builder can then use the cached layer when rebuilding the image and for other images during the build process if the same instruction is used. By using cached layers, the builder could potentially deny fresh updates to be included in later container image builds.",,check-registry-layer,,
The Container Image Must Be Created Without Confidential Data in the Build Files,9,CCI-000366,"When container images are created with private or classified data (e.g., passwords, tokens, and keys) stored within the build file, the data can be backtracked easily by using native commands for the container platform or by using various external tools. These build files are often shared, and without removal of the confidential data, would become exposed and potentially exploited. Even if the data is deleted later, it can be retrieved from the container image history. When authentication is necessary during the container image build process, secrets stored in authentication management service must be used.",,check-confidential-data,,
The Container Images Must Be Created from Signed Base Images,10,CCI-001749,Image building must start with a trusted image with known content from a trusted source. Digital signatures of container images provide the capability to trust container image content when container images are sent to and received from remote registries. These signatures allow client-side verification of the integrity and publisher of specific image tags and ensures provenance of container images.,,check-base-image-signature,,
The Container Image Must Be Created with Verified Packages,11,CCI-001749,Container image content trust starts with the installation of known and trusted packages. Verifying the authenticity of packages during each container image build step ensures the container image remains secure. Packages installed from untrusted or unknown sources could be tampered with and could potentially have malicious code or unknown vulnerabilities that could be exploited.,,allowed-packages,,
The Container Image Must Be Created with Only Essential Capabilities,12,CCI-000381,"To minimize the attack surface of a container, only those capabilities essential to the service offered by the container should be installed. When container images become bloated with unnecessary software, the attack surface grows along with the need for subsequent security patch maintenance. This also negates the concept of containers being microservices.",,check-image-size-and-layers,,
The Container Image Must Only Enable Ports Used for the Service Being Implemented,13,CCI-001762,"To minimize the attack surface, each container image should be a microservice, implementing only one service where possible. Many services require enabled ports for communication. Exposing ports unnecessary for service implementation allows the container to expand the attack surface by giving external malicious users information regarding applications and their versions that are enabled within the container, and possible vulnerabilities that might be used to attack the container.",,restrict-ports-based-on-image,,
The Container Image Must Be Built from a DoD Approved Base Image,14,CCI-002422,"During transmission, a container base image can be changed by a malicious user. To thwart this effort, the hash of the container base image must be compared against the known hash from the trusted source.",,allowed-base-images,,
Container Images No Longer in Use Due to Updated Versions Must Be Removed,15,CCI-002617,"Container images are stored within the container platform's registry. When deploying a container, ensure the container being instantiated is the desired container. One way to instantiate the correct container image is by using tags, but tags can be manipulated to force a container image with known vulnerabilities to be used when a more secure image is available. To help ensure newer and more secure images are always instantiated, older images must be deleted from the registry. This includes Certificate to Field (CTF) approvals where critical vulnerabilities may exist in older versions and need to be revoked.
When building a container image, ensure the base image being used for the build is the desired image. Accidentally building with an older and more vulnerable base image leads to those vulnerabilities perpetuating into child images.",,detect-deprecated-images,,
The Container Image Must Implement Any STIG or SRG Guidance Relevant to the Container Service,16,CCI-000366,"Practices to handle container image build and deployment must be followed, as the container is also implementing a service. To fully harden container images, any STIG or SRG documents for the service being implemented must be applied during the container image creation. In cases where a traditional STIG may not entirely apply for a scan of a container, or a container may need to run as root as an exception, a waiver will need to be approved. In these cases, until container guidance is created for each technology, waivers will need to be approved for each exception as needed.",,,,
The Container Image Must Be Created from a Trusted and Approved Source,17,CCI-000185,"Choosing images from trusted and approved sources is the beginning of creating container images with known security postures. When unknown public sources are used, the container may contain malicious code and services that result in undesired implementations. Trusted sources must use valid registry certificates to sign their hosted images. Consumers of these images must verify the authenticity of signed container images when downloaded from the trusted source.
Please see section 6 Appendix A for a list of trusted sources.",,restrict-image-registries,,
The Container Image Must Be Clear of Embedded Credentials,18,CCI-002367,"A container may require passwords, secrets, or keys to connect to other applications such as backend databases. The credentials must be kept externally, fetched by the application, and not stored in the container image. If the credentials are stored within the container image, anyone with access to the image can parse the credentials.",,check-credentials-in-image,,
A Container Must Not Mount the Container Platform's Registry Endpoint,19,CCI-001090,"The registry socket is used by client tools to interact with the registry. If a container can mount the socket, it can execute registry commands such as running images, deleting images, or pulling nefarious images into the registry.",,disallow-registry-socket,,
A Container Must Be Limited in Available System Calls,20,CCI-001090,Secure computing mode (SECCOMP) is a security facility in the Linux Kernel. The facility enables a security posture where containers are limited in the system calls available to the process. The default SECCOMP profile provides a default security posture for running containers while providing wide application compatibility.,,restrict-seccomp,,
Enable PIDs Control Groups to Limit and Account for Container Resource Usage,21,CCI-001090,"Control groups (cgroups) is a Linux kernel feature that limits, accounts for, and isolates resource usage (central processing unit (CPU), memory, disk I/O, network, etc.) of a container. By implementing cgroups, each container is guaranteed a share of the resources, but more importantly, it guarantees that a single container does not bring the container platform down by exhausting resources.",,require-requests-limits,,
Sensitive Directories on the Host System Must Not Be Mounted by Containers,22,CCI-001090,"Sensitive data on the host system must be protected from containers running within the container platform. To protect the data, it is important to verify which directories can be, and are mounted by executing containers. If a container is granted access directly or inherits access to directories containing sensitive data when the container is not authorized to the data, the data can be used by the container for an attack or offloaded for later use. Examples on a Linux server of sensitive directories are /etc and /usr.",,disallow-host-path,,
The Container Should Have Resource Limits Set,23,CCI-001094,"The resource limit setting for a container provides a limit or maximum amount of resources a container can consume. Without this limit, a container can use all available resources, starving other containers of needed resources, causing a Denial of Service (DoS) across all the services executing within the container platform.",,require-requests-limits,,
The Container Should Have Resource Request Set,24,CCI-001095,"Setting a container resource request limit allows the container platform to determine the best location for the container to execute. The container platform looks at the resources available and finds the location that will require the minimum resources for the container to execute. Examples of resources that can be specified are CPU, memory, and storage.",,require-requests-limits,,
The Container root filesystem Must Be Mounted as Read-Only,25,CCI-001813,"Any changes to a container must be made by rebuilding the image and redeploying the new container image. Once a container is running, changes to the root filesystem should not be needed, thus preserving the immutable nature of the container. Any attempts to change the root filesystem are usually malicious in nature and can be prevented by making the root filesystem read-only.",,require-ro-rootfs,,
The Container Must Have a Liveness Probe,26,CCI-002385,A liveness probe checks for instances in which a container has run into a deadlock state. The container will appear as healthy from the process health check's point of view but will not be in a usable state. This check is performed at the container level for healthiness.,,require-pod-probes,,
The Container Must Have a Readiness Probe,27,CCI-002385,"Process health checks and liveness probes are helpful to determine if a container is unhealthy and needs to be restarted, however restarting does not always make the container healthy and may keep the container in an apparent unhealthy state (for example, when the container is starting and is not ready to receive any workload, including the health check or liveness probe). The readiness probe can also be used to monitor if a container is overloaded, latency has increased, and the container needs to be shielded from additional workloads.",,require-pod-probes,,
A Container Must Not Have Access to Operating System Kernel Namespaces,28,CCI-001090,"Namespaces provide a straightforward way of isolating containers. Using isolation, services within a container cannot see or access services running within other containers or on the container platform host system. When kernel namespaces are shared to containers, data can be shared directly between services bypassing security measures, allowing containers to elevate their privileges.
The important namespaces to protect are the network (net) namespace, which virtualizes the network stack; the process ID (PID) namespace, which contains the process IDs of all running processes; the Inter-Process Communication (IPC) namespace, which isolates containers from using SysV inner-process communication; Unix Time Sharing (UTS), which would allow a container to appear to have different host and domain names to different processes; and the userID (user) namespace, which provides both privilege isolation and user identification segregation across containers.",,disallow-host-namespaces,,
The Container Should Be Given Label Selectors to Help Define Container Execution Location and Type,29,CCI-002530,"Using label selectors, containers can be given priority based on where they are executed according to characteristics of the service or the user community. Examples of labels include the type of service, such as management versus customer, or the type of data on which the container operates, such as HR versus Sales or the DoD role of the container such as GPU vs CPU. Labeling the containers aids in the location of execution, reducing any data spillage or inadvertent resource sharing.",,require-labels,,